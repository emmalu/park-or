import{e as $,n as F}from"./cast-6d78d3c7.js";import{n as K}from"./ExpandedCIM-91f67fd3.js";import"./Error-4ed679d7.js";import"./string-9c5e03f7.js";import{o as I,t as M,r as v,f as E,e as L}from"./typedArrayUtil-d02f10a8.js";import{j as C,f as _}from"./promiseUtils-930cba29.js";import"./ensureType-d98e08e1.js";import{m as A,a as T}from"./diffUtils-713e5c9b.js";import{k as P}from"./Extent-d5fff12d.js";import{p as O}from"./visualVariablesUtils-9310c846.js";import{S as U}from"./enums-4ca4641f.js";import{x as z,l as k,b as B,E as j,t as H}from"./Matcher-1409f335.js";import{p as J}from"./BaseProcessor-295710df.js";import"./nextTick-3ee5a785.js";import"./Color-b7b9e6bb.js";import"./colorUtils-639f4d25.js";import"./mathUtils-daf59e84.js";import"./common-701a4199.js";import"./screenUtils-7afeb41c.js";import"./arcadeOnDemand-72c57f7a.js";import"./preload-helper-101896b7.js";import"./geometry-70b2a4a5.js";import"./Polyline-42dcc920.js";import"./typeUtils-b6c52390.js";import"./jsonMap-5afaf2ff.js";import"./BidiEngine-836b7ef6.js";import"./aaBoundingRect-ca34962d.js";import"./jsonUtils-5115c7e5.js";import"./enums-ef042d89.js";import"./MaterialKey-cec287ae.js";import"./mat2d-80bd93af.js";import"./vec2-f978aef8.js";import"./vec2f32-461e65a9.js";import"./Utils-b6ef920f.js";import"./enums-64ab819c.js";import"./Texture-c2297638.js";import"./context-util-abf86a85.js";import"./VertexElementDescriptor-2925c6af.js";import"./Rect-ea14f53a.js";import"./quantizationUtils-8770173e.js";import"./GeometryUtils-eebff0a0.js";import"./floatRGBA-305df8f3.js";import"./Collection-42fe629f.js";import"./Evented-b378ccab.js";import"./SimpleObservable-e0897cc6.js";import"./visualVariablesUtils-4833b8d3.js";import"./TileStrategy-40f1ecb0.js";import"./TileStore-a368d16c.js";import"./Queue-8aae62d3.js";import"./TileKey-ed432ae5.js";import"./rbush-8e36784a.js";import"./quickselect-322ec8e1.js";import"./Query-066f2ccf.js";import"./TimeExtent-0fd238ea.js";import"./enumeration-497ef064.js";import"./Field-bb784640.js";import"./fieldType-9bddd3d4.js";import"./Clonable-58355d3c.js";import"./tileUtils-23b52606.js";import"./TileClipper-48ccb501.js";import"./assets-6ba3cd63.js";import"./request-e4299080.js";import"./Geometry-daada628.js";import"./GeometryUtils-c093d234.js";import"./featureConversionUtils-d9ec654e.js";import"./OptimizedFeature-1bba65b5.js";import"./OptimizedFeatureSet-1d1ac4b9.js";import"./defaultsJSON-b087dd4d.js";import"./earcut-58237617.js";import"./LRUCache-4d56ba4d.js";import"./MemCache-1e028041.js";import"./devEnvironmentUtils-5002a058.js";import"./Portal-fbb2b73d.js";import"./Loadable-b0d5bb7e.js";import"./Promise-6bd0b483.js";import"./locale-30120714.js";import"./PortalGroup-813428fa.js";import"./PortalUser-cf18ae9d.js";import"./persistableUrlUtils-d18becd9.js";import"./styleUtils-0c73f570.js";import"./HandleOwner-6ac6f00a.js";import"./reactiveUtils-b0e56010.js";class N{constructor(e){this._remoteClient=e,this._resourceMap=new Map,this._inFlightResourceMap=new Map,this.geometryEngine=null}destroy(){}async fetchResource(e,s){const r=this._resourceMap,i=r.get(e);if(i)return i;let o=this._inFlightResourceMap.get(e);if(o)return o;try{o=this._remoteClient.invoke("tileRenderer.fetchResource",{url:e},{...s}),this._inFlightResourceMap.set(e,o),o.then(a=>(this._inFlightResourceMap.delete(e),r.set(e,a),a))}catch(a){return C(a)?null:{width:0,height:0}}return o}getResource(e){return this._resourceMap.get(e)??null}}function x(t,e){return(!t.minScale||t.minScale>=e)&&(!t.maxScale||t.maxScale<=e)}function D(t){const e=t.message,s={message:{data:{},tileKey:e.tileKey,tileKeyOrigin:e.tileKeyOrigin,version:e.version},transferList:new Array};for(const r in e.data){const i=e.data[r];if(s.message.data[r]=null,v(i)){const o=i.stride,a=i.indices.slice(0),l=i.vertices.slice(0),m=i.records.slice(0),p={stride:o,indices:a,vertices:l,records:m,metrics:I(i.metrics,c=>c.slice(0))};s.transferList.push(a,l,m),s.message.data[r]=p}}return s}let S=class extends J{constructor(){super(...arguments),this.type="symbol",this._matchers={feature:null,aggregate:null},this._bufferData=new Map,this._bufferIds=new Map}initialize(){this.handles.add([this.tileStore.on("update",this.onTileUpdate.bind(this))]),this._resourceManagerProxy=new N(this.remoteClient)}destroy(){this._resourceManagerProxy.destroy()}get supportsTileUpdates(){return!0}forEachBufferId(t){this._bufferIds.forEach(e=>{e.forEach(t)})}async update(t,e){const s=e.schema.processors[0];if(s.type!=="symbol")return;const r=A(this._schema,s);(T(r,"mesh")||T(r,"target"))&&(t.mesh=!0,t.why.mesh.push("Symbology changed"),this._schema=s,this._factory=this._createFactory(s),this._factory.update(s,this.tileStore.tileScheme.tileInfo))}onTileMessage(t,e,s,r){return _(r),this._onTileData(t,e,s,r)}onTileClear(t){const e={clear:!0};return this._bufferData.delete(t.key.id),this._bufferIds.delete(t.key.id),this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:t.id,data:e})}onTileError(t,e,s){const r=s.signal,i={tileKey:t.id,error:e};return this.remoteClient.invoke("tileRenderer.onTileError",i,{signal:r})}onTileUpdate(t){for(const e of t.removed)this._bufferData.has(e.key.id)&&this._bufferData.delete(e.key.id),this._bufferIds.has(e.key.id)&&this._bufferIds.delete(e.key.id);for(const e of t.added)this._bufferData.forEach(s=>{for(const r of s)r.message.tileKey===e.id&&this._updateTileMesh("append",e,D(r),[],!1,!1,null)})}_addBufferData(t,e){this._bufferData.has(t)||this._bufferData.set(t,[]),this._bufferData.get(t).push(D(e))}_createFactory(t){const{geometryType:e,objectIdField:s,fields:r}=this.service,i=(p,c)=>this.remoteClient.invoke("tileRenderer.getMaterialItems",p,c),o={geometryType:e,fields:r,spatialReference:P.fromJSON(this.spatialReference)},a=new z(i,this.tileStore.tileScheme.tileInfo),{matcher:l,aggregateMatcher:m}=t.mesh;return this._store=a,this._matchers.feature=k(l,a,o,this._resourceManagerProxy),this._matchers.aggregate=I(m,p=>k(p,a,o,this._resourceManagerProxy)),new B(e,s,a)}async _onTileData(t,e,s,r){_(r);const{type:i,addOrUpdate:o,remove:a,clear:l,end:m}=e,p=!!this._schema.mesh.sortKey;if(!o){const h={type:i,addOrUpdate:null,remove:a,clear:l,end:m,sort:p};return this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:t.id,data:h},r)}const c=this._processFeatures(t,o,s,r,e.status.version);try{const h=await c;if(M(h)){const n={type:i,addOrUpdate:null,remove:a,clear:l,end:m,sort:p};return this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:t.id,data:n},r)}const u=[];for(const n of h){let d=!1;const g=n.message.bufferIds,f=t.key.id,b=n.message.tileKey;if(f!==b&&v(g)){if(!this.tileStore.get(b)){this._addBufferData(f,n),u.push(n);continue}let y=this._bufferIds.get(b);y||(y=new Set,this._bufferIds.set(b,y));const R=Array.from(g);for(const w of R){if(y.has(w)){d=!0;break}y.add(w)}}d||(this._addBufferData(f,n),u.push(n))}await Promise.all(u.map(n=>{const d=t.key.id===n.message.tileKey,g=d?e.remove:[],f=d&&e.end;return this._updateTileMesh(i,t,n,g,f,e.clear,r.signal)}))}catch(h){this._handleError(t,h,r)}}async _updateTileMesh(t,e,s,r,i,o,a){const l=t,m=s.message.tileKey,p=!!this._schema.mesh.sortKey;m!==e.key.id&&(i=!1);const c=I(s,d=>d.message),h=I(s,d=>d.transferList)||[],u={type:l,addOrUpdate:c,remove:r,clear:o,end:i,sort:p},n={transferList:L(h)||[],signal:a};return _(n),this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:m,data:u},n)}async _processFeatures(t,e,s,r,i){if(M(e)||!e.hasFeatures)return null;const o={transform:t.transform,hasZ:!1,hasM:!1},a=this._factory,l={viewingMode:"",scale:t.scale},m=await this._matchers.feature,p=await this._matchers.aggregate;_(r);const c=this._getLabelInfos(t,e);return await a.analyze(e.getCursor(),this._resourceManagerProxy,m,p,o,l),_(r),this._writeFeatureSet(t,e,o,c,a,s,i)}_writeFeatureSet(t,e,s,r,i,o,a){const l=e.getSize(),m=this._schema.mesh.matcher.symbologyType,p=new j(t.key.id,{features:l,records:l,metrics:0},m,o,m!==U.HEATMAP,a),c={viewingMode:"",scale:t.scale},h=e.getCursor();for(;h.next();)try{const n=h.getDisplayId(),d=v(r)?r.get(n):null;i.writeCursor(p,h,s,c,t.level,d,this._resourceManagerProxy)}catch{}const u=t.tileInfoView.tileInfo.isWrappable;return p.serialize(u)}_handleError(t,e,s){if(!C(e)){const r={tileKey:t.id,error:e.message};return this.remoteClient.invoke("tileRenderer.onTileError",r,{signal:s.signal})}}_getLabelingSchemaForScale(t){const e=this._schema.mesh.labels;if(M(e))return null;if(e.type==="subtype"){const r={type:"subtype",classes:{}};let i=!1;for(const o in e.classes){const a=e.classes[o].filter(l=>x(l,t.scale));i=i||!!a.length,r.classes[o]=a}return i?r:null}const s=e.classes.filter(r=>x(r,t.scale));return s.length?{type:"simple",classes:s}:null}_getLabels(t,e){if(e.type==="subtype"){const s=this.service.subtypeField,r=E(s,"Expected to find subtype Field"),i=t.readAttribute(r);return i==null?[]:e.classes[i]??[]}return e.classes}_getLabelInfos(t,e){const s=this._getLabelingSchemaForScale(t);if(M(s))return null;const r=new Map,i=e.getCursor();for(;i.next();){const o=i.getDisplayId(),a=[],l=O(o),m=l&&i.readAttribute("cluster_count")!==1?"aggregate":"feature",p=this._getLabels(i,s);for(const c of p){if(c.target!==m)continue;const h=i.getStorage(),u=l&&m==="feature"?h.getComputedStringAtIndex(i.readAttribute("referenceId"),c.fieldIndex):h.getComputedStringAtIndex(o,c.fieldIndex);if(!u)continue;const n=K(u.toString()),d=n[0],g=n[1];this._store.getMosaicItem(c.symbol,H(d)).then(f=>{a[c.index]={glyphs:f.glyphMosaicItems,rtl:g,index:c.index}})}r.set(o,a)}return r}};S=$([F("esri.views.2d.layers.features.processors.SymbolProcessor")],S);const Mt=S;export{Mt as default};
